CPU对内存的操作有对并的概念：
如果操作1字节的数据，可以是任意地址，如果是操作2字节的数据，如果开始地址在偶数地址，一次就可以取2字节，如果开始地址在奇数，就要2次内存操作才能完成；如果操作4字节的数据，最好开始地址在能被4整除的数值上，这样可以用一条32位的内存操作指令完成。同样，8字节的开始位置最好的能被8整除的数值上，这样可以用一条64位的内存操作指令完成。
就是说，如果对齐了，一次就可以完成，不对齐，就可能多次才能完成。编译程序处理时也有对齐处理，一般的结构体和对象等估计都有对齐的处理（把结构体或对象的开始位置定在边界上），这样，只要你在结构体里对象之间能处理好对齐，你的数据就能操作得很快。
有时你定义了一个结构体，用了若干字节，但不是8或4的倍数，但你查内存时能发现它们占用的是8或4的倍数（多用了几个字节），就是这个原因。
补充回答：
比如32位机，32根地址线，32根数据线，取数时，CPU的32根据地址线与内存的0-3号地址对齐，CPU的32位的数据线也同样，一个读取周期只能取这0-3地址的3个字节。如果你是取3-4地址的数据，CPU会自动把它分解成2次取数据操作，一次取8位的3单元和一次取8位4单元数据。
只有开始地址是0、4、8...的32位的数据操作才能一次操作完成，内存不支持从1号单元开始的4字节读，CPU和内存的数据线必须相应数据线对齐才行。
如果要没有这个限制，CPU和内存的制作成本就会高一些。况且，CPU和内存的控制总线标准是早就规定好了的，造CPU的生产出了有你这种功能的CPU，但内存不支持，必须某年某月国际上协商出了新的标准，你的这种想法才可能实现。
